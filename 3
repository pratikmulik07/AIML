def depth_first_search(graph, start, goal):
    visited = set()
    order = []  # order of visited nodes
    path = []   # actual path to goal

    def dfs(node):
        visited.add(node)
        order.append(node)
        path.append(node)

        if node == goal:
            return True  # goal found

        for neighbour in graph[node]:
            if neighbour not in visited:  # avoid re-visiting
                if dfs(neighbour):  # recursive call
                    return True  # stop when goal found

        path.pop()  # backtrack
        return False  # goal not found in this route

    dfs(start)
    return order, path


# ---- Sample Game Map ----
graph = {
    "Camp": ["Forest", "River"],
    "Forest": ["Cave", "Clearing"],
    "Clearing": ["Tower"],
    "River": ["Waterfall"],
    "Cave": ["Treasure Room"],
    "Tower": ["Treasure Room"],
    "Waterfall": [],
    "Treasure Room": []
}

starting = "Camp"
goal = "Waterfall"

order, path = depth_first_search(graph, starting, goal)

print("Traversal Order:")
for step, node in enumerate(order, start=1):
    print(f"{step}. {node}")

if path and path[-1] == goal:
    print("\nTreasure Path:", " -> ".join(path))
else:
    print("\nGoal not found!")
